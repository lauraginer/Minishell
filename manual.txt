ðŸ§­ FLUJO COMPLETO DEL FUNCIONAMIENTO DE MINISHELL
ðŸŸ  1. Inicio del bucle principal (Minishell Main Loop)
Responsable: minishell

while (1)
{
    show_prompt();
    input = readline();
    add_history(input);
    ...
}

âœ… Cosas que se hacen aquÃ­:

Mostrar el prompt.

Leer la lÃ­nea con readline.

AÃ±adir al historial si no estÃ¡ vacÃ­a.

Comprobar si el input estÃ¡ vacÃ­o o es Ctrl+D.


ðŸ”µ 2. Parseo (AnÃ¡lisis del input)
Responsable: parser

parsed_cmds = parse_input(input);
âœ… Cosas que hace el parser:

Separar comandos por pipes (|).

Detectar redirecciones (>, <, >>, <<).

Separar argumentos y aplicar expansiÃ³n de variables ($VAR, $?).

Manejar comillas simples y dobles correctamente.

Validar errores de sintaxis (por ejemplo: |, comillas sin cerrar...).

ðŸ›‘ Si hay un error de parseo, abortar antes de ejecutar.


ðŸŸ¢ 3. EjecuciÃ³n
Responsable: executor

exec_cmds(parsed_cmds, env);
âœ… Cosas que haces en ejecuciÃ³n:

A. PreparaciÃ³n
Si hay una sola instrucciÃ³n sin pipe y es un built-in â†’ ejecÃºtalo en el proceso padre directamente.

B. Pipes y Forks
Si hay mÃºltiples comandos (con pipes) â†’ crear n procesos.

Conectar las salidas/entradas de cada uno con pipe y dup2.

C. Built-ins vs externos
Detectar si el comando es un built-in o uno externo.

Para externos:

Buscar el ejecutable en PATH.

Usar execve.

D. Redirecciones
Aplicar dup2 para <, >, >>, << antes de ejecutar cada comando.


E. FinalizaciÃ³n
Esperar con waitpid a que terminen los hijos.


Recoger el cÃ³digo de salida y guardarlo para $?.

ðŸŸ£ 4. LiberaciÃ³n y bucle
Responsable: minishell

âœ… Cosas que haces despuÃ©s de ejecutar:

Liberar memoria del input y estructuras.

Volver al while (1) para mostrar el prompt de nuevo.